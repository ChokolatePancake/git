# Git

- `git checkout -b` (створення нової гілки)
- `git add .` (додає зміни до індексу)
- `git status` (виводить різницю між індексом і робочою текою)
- `git commit -m "test"` (створення нового коміту)
- `git push --set-upstream origin test` (відправлення на віддалений сервер)

- `git checkout` (переключення на гілку)
- `git revert` створює новий коміт з протилежними змінами до поточного (якщо щось видалено, то буде додано, якщо додано, то буде видалено)

`git reset` має кілька варіацій: mixed (default), soft, hard.
- Soft залишає всі зміни в індексі і в будь-який момент можна створити новий коміт (наприклад було кілька комітів, але їх треба об'єднати в один)
- Mixed (за замовчуванням) видаляє зміни з індексу, але лишає в робочій теці (наприклад було закомічено зайвий файл, після ресету можна додати потрібні файли і закомітити)
- Hard повністю видаляє коміти з їх змінами усюди

------------------------------------------------------------------------------
- `git rebase` дає можливість перенести коміти з однієї гілки на іншу
- `git cherry-pick` дає можливість перенести один або кілька конкретних комітів

`git commit --amend` (дозволяє змінити останній коміт зберігаючи чистоту історії комітів, корисне коли треба змінити повідомлення або щось додати)
Варто використовувати на ще не запушених комітах (інакше доведеться застосувати git push --force), при значних змінах краще створити новий коміт
Додаткові опції:
- `-m "some text"` (для зміни повідомлення не заходячи в редактор)
- `--no-edit` (для зміни лише наповнення коміта, без зміни повідомлення)
- `--edit` (дефолтна опція, що відкриває текстовий редактор для редагування повідомлення)
- `--reset-author` (для зміни автора коміту)
- `--no-verify` (ігнорує попередньо налаштовані перевірки)
- `--date="some date"` (для задання нової дати коміту)
- `--author="author <author@example.com>"` (для задання нового автора та електронки)

`git reset --hard ORIG_HEAD` (перша частина примусово повертає гілку до вказаного коміту, а саме ORIG_HEAD)
ORIG_HEAD - точка повернення до останньої великої операції (merge, rebase, reset, pull)

`git log` (відображає коміти на поточній гілці)

`git reflog` (показує усі зміни, в тому числі коміти, які вже є недоступними через зміни в гілках або скидання, також показує усі операції з гілками)

`git tag "tag name"` (дозволяє створювати теги на конкретний коміт)
Додаткові опції:
- `-l` (без вказування "tag name", виводить список усіх тегів, можна фільтрувати наприклад "a*" виведе усі теги, що починаються на "a")
- `-a` (анотований тег, якщо окрім самої назви тега треба додаткова інформація, після -a пишеться власне назва)
- `-m` (повідомлення анотованого тегу)
- `-f` (force, примусове переписування тегу)
- `-d` (delete, видалення тегу)
- `--contains <commit>` (показує теги, які містить вказаний коміт)
- `--points-at <object>` (показує теги, які вказують на об'єкт (коміт, гілку))
- `--edit` (дозволяє відредагувати існуючий анотований тег)

`git fetch` (підтягує зміни з віддаленого репозиторію до локального, але не об'єднує їх)

`git pull` (підтягує зміни та зливає з локальною гілкою)

`git stash` (дозволяє зберегти незакомічені зміни локально, при цьому наче вирізаючи їх. Коли на гілці є зміни, які не готові ще до коміту, але необхідно перейти на іншу гілку, stash вертає теку в стан останнього коміту, а сам зберігає усі зміни, тож завжди можне вернутися до того, на чому зупинився. Зміни зберігаються стеком десь в папці .git/objects)


`git stash pop`(відновлює зміни, вирізаючи їх зі стеку)

`git stash apply`(відновлює зміни, але також залишає їх в стеку)

`git stash list`(для перегляду усіх прихованих змін)

`git stash push -m "some text"`(зберігає в стек з вказаним повідомленням)

`git stash show`(показує зміни в останньому записі стешу)

`git stash drop`(видаляє або останній, або вказаний запис стешу)

`git stash clear`(видаляє всі записи стешу)

--------------------------------------------------------------------------------------------------

git hooks - скрипти, які запускаються при виконанні певних дій(в папці .git/hooks є зразки різних хуків:
- applypatch-msg.sample
- pre-applypatch.sample
- pre-push.sample
- update.sample
- commit-msg.sample
- pre-commit.sample
- pre-rebase.sample
- fsmonitor-watchman.sample
- pre-merge-commit.sample
- pre-receive.sample
- post-update.sample
- prepare-commit-msg.sample
- push-to-checkout.sample)


`git bisect`(для пошуку коміту з помилкою шляхом бінарного пошуку за допомогою позначення коміта як хороший чи поганий)
Варіації команди:
- `start`(починає процес)
- `reset`(скасовує процес і повертає туди, звідки почали)
- `bad` (позначити коміт як поганий, якщо не вказано конкретний коміт, то позначається поточний)
- `good`(аналогічно з попереднім, але позначає як хороший)
- `run <script>`(для запуску скрипта за яким автоматично перевірятиме)
- `log`(перегляд поточного статусу, можна дописати `>*.txt` для запису в файл)
- `replay <file>`(повторює бісекцію на основі раніше створеного файлу за допомогою `log`)


`git submodule`(включення одного репозиторію в інший)
Варіаці команди:
- `add`(додавання сабмодуля)
- `init`(ініціалізація, можна також використовувати `--init` разом з іншими командами)
- `update`(оновлення)
- `--recursive`(рекурсивно, наприклад можна оновити за допомогою попередньої команди усі сабмодулі і їх сабмодулі)
- `--remote`(для оновлення до останніх комітів)
- `status`(статус сабмодулів, включаючи інформацію про їх коміти та стан)
- `summary`(короткий огляд змін у сабмодулях у порівнянні з останнім комітом, на який посилаєтеся основномий репозиторій)
- `foreach <command>`(виконує вказану команду для кожного сабмодуля)

`git clone --recurse-submodules`(при клонуванні репозиторію разом з його сабмодулями ініціалізуючи та оновлюючи їх)

Перейшовши в папку сабмодуля, можна працювати з ним як зі звичайним репозиторієм. Всі зміни в сабмодулі відслідковуються окремо, а основний репозиторій зберігає посилання на конкретний коміт у цьому сабмодулі.
На сторінці основного репозиторію в github папка з сабмоулем(назва містить: "назва репозиторію" @ "назва коміту скорочено") буде посилати на підключений коміт

Для видалення сабмодуля необхідно видалити його з індексу(`git rm --cached -r <path>`), запис про нього в `.git/config` та в файлі `.gitmodules`, його теку, шлях до якої вказувався при додаванні та в `.git/modules`(якщо видалити лише в `.git/modules`, то папка, яка вказувалася при створенні стане просто набором файлів, а не посиланням на інший репозиторій)
